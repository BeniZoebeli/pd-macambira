PureUnity

Mathieu Bouchard <matju@artengine.ca>

January 13th, 2006

Abstract

This paper covers the theory behind PureUnity, 
PureData's test framework.

Table of Contents

1 What is testing?
    1.1 a test tests something that gets tested
    1.2 a triad of testing
2 Methodologies of Testing
    2.1 test-by-Proof
    2.2 test-by-Use
    2.3 test-by-Rule
    2.4 test-by-Example
3 Quelques cossins
    3.1 Protocol
    3.2 Preconditions
    3.3 Postconditions
    3.4 Wrapconditions
    3.5 Inheritance
    3.6 Aspect-programming and stuff
    3.7 Meta-abstractions
    3.8 Float-Signal Polymorphism
    3.9 Unit-Tests
    3.10 Algebraic Properties
    3.11 Temporal Logic
    3.12 TODO



1 What is testing?

1.1 a test tests something that gets tested

(write ontological nonsense here)

1.2 a triad of testing

I've thought of a triad:

A. "the real thing"

B. what it's documented as

C. a way to verify that (1) and (2) agree

and another one:

changing A to match B+C: programming

changing B to match A+C: the scientific method (aka 
reverse engineering)

changing C to match A+B: unit-tests and contracts and 
scientific experiments

2 Methodologies of Testing

I once called unit-tests "test-by-example" and 
contracts "test-by-rule". I think that those names are 
preferable to the more common names. I also hadlisted 
"test-by-use" which is to use the software in practice: 
this may include testing a component A using the unit 
tests for B because B uses A.The last I had listed was 
"test-by-proof", which is rarer and is the only one 
that requires analysing the implementation.

2.1 test-by-Proof

2.2 test-by-Use

2.3 test-by-Rule

2.4 test-by-Example

3 Quelques cossins

3.1 Protocol

3.2 Preconditions

3.3 Postconditions

3.4 Wrapconditions

3.5 Inheritance

3.6 Aspect-programming and stuff

3.7 Meta-abstractions

3.8 Float-Signal Polymorphism

3.9 Unit-Tests

3.10 Algebraic Properties

3.11 Temporal Logic

3.12 TODO
